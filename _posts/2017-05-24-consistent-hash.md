---
layout: post
title: "一致性哈希算法的使用分析"
comments: true
keywords: ""
author: 'ddinnnng@gmail.com'
---

<h4>业务场景</h4>

<p>因为业务访问量激增，单台redis已经无法满足需求，因此需要搭建一个redis集群来增加服务及负载能力。原先的往单台redis写数据的逻辑变成往多台机器写，为了保证我们能正确的找到我们的缓存数据，一般的做法是Hash(key) % N（N是机器的个数）求余定位到一台固定的机器，OK没问题，我们解决了现阶段的问题。但是随着业务量的持续激增，我们再次需要扩充redis集群，比如从原先的5台，扩充到10台，这样我们原先的数据路由公式 Hash(key)%5变成 了 Hash(key)%10，但是这样会有一个很严重的问题，就是我原先的key再次经过Hash求余所得到的结果和上次不一样，导致原先几乎所的缓存失效，重新生成新缓存的过程对一个大流量的业务来说这是一个灾难。 </p>

<p>我们再来看一个问题，现在我们有一个100台机器的redis集群，由于某些原因其中2台宕机，那么之前路由到这两台机器的key读写都会error，正常我们会将这两台机器从集群中剔除，修复后再重新添加到集群。整个集群机器数量的变化是从100-&gt;98-&gt;100，按照之前的路由算法那么任然会产生几乎原先所有的key都失效的问题。还有一种情况是根据业务量峰值分布需要对集群进行动态伸缩也会遇到这种问题。</p>

<p><strong>一致性哈希算法出现的目的就是为了使用最小的代价去完成依赖哈希算法路由的集群的动态伸缩。 </strong></p>

<h4>一致性哈希算法的原理 </h4>

<p>一致性哈希算法需要满足两个比较重要的特性，一个是<strong>单调性</strong>，还有一个是<strong>均衡性</strong>。单调性是指通过哈希算法得出某个key被分配到某个节点中，当有新的节点加入时，算法可以保证原有已分配的key可以映射到满足条件的新的节点中，而不会映射到其他节点。均衡性是指通过一致性哈希算法可以将所有的key尽可能的均匀的分配到每个节点中。 </p>

<p>一致性哈希算法将0到(2^32-1)的数字范围组成一个环形空间，所有的服务器节点和缓存对象都分配在这个环形空间中。按照顺时针防线，被缓存对象都被映射到离自己最近的那个服务器节点中。如下图： </p>

<figure><img src="http://7xp1dj.com1.z0.glb.clouddn.com/hash-1.jpeg"/></figure>

<p>图中Cache A、Cache B、Cache C三台服务器通过Hash算法得出key A、Key B、Key C分布在环上，对象object 1、object 2、object 3、object 4同时分布在环上的各个位置，根据规则按照顺时针方向，四个对象存储到离自己最近的Cache 节点中，object 4-&gt;Cache B，object 3, object 2-&gt;Cache C，object 1 -&gt;Cache A。 </p>

<p>环形Hash空间的优势很明显，环上的服务器节点的增减只对其上一个服务器节点（顺时针）到其本身之间的数据有影响（需要重新路由），而对其他区间的数据没有任何影响。当服务器节点数量很多，这种优势则体现得更加明显。 </p>

<figure><img src="http://7xp1dj.com1.z0.glb.clouddn.com/hash-2.jpeg"/></figure>

<p>上图中Cache B节点被剔除（增加节点也是一样），按照一致性Hash算法规则，我们只需要将原先路由到Cache B中的对象全部路由到Cache C中即可，原先路由到Cache C和路由到Cache A中的对象不用改变，这样就能保证在环上增删节点时影响的数据范围最小。</p>

<p>环形Hash空间也有一个弊端，也是我们需要着重解决的问题，就是分配不均匀的问题（平衡性）。当所有的服务器节点都只分布在环上的一小块时，就会导致某几台服务器负载过大，而其他机器则没有得到合理利用。解决平衡性问题简单的办法就是大量的增加环上的服务器节点数量，在物理机数量的基础上虚拟出部分机器分布到环上，比如一台物理机节点虚拟出4台虚拟虚拟节点，而这四个节点上的所有数据都是保存在这台物理机节点中。这样可以间接的解决平衡性问题。真实节点和虚拟节点之间的路由关系如下图： </p>

<figure><img src="http://7xp1dj.com1.z0.glb.clouddn.com/hash-5.jpeg"/></figure>

<p>虚拟节点的Hash计算可以采用真实节点的IP加上数字编号的方式实现，如192.168.0.1#1，192.168.0.1#2... </p>

<p>下面附上一段PHP实现一致性Hash算法的Demo： </p>

<p><a href="https://github.com/1024b/CHash">[CHash]</a></p>